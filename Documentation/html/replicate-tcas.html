

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How to replicate the results in the TCAS-I paper &mdash; PyDSM 0.5.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.5.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyDSM 0.5.1 documentation" href="index.html" />
    <link rel="prev" title="Computation of the impulse response of a filter" href="utility-modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="utility-modules.html" title="Computation of the impulse response of a filter"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyDSM 0.5.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="how-to-replicate-the-results-in-the-tcas-i-paper">
<h1>How to replicate the results in the TCAS-I paper<a class="headerlink" href="#how-to-replicate-the-results-in-the-tcas-i-paper" title="Permalink to this headline">¶</a></h1>
<p>This section illustrates how to replicate the results presented in the
paper</p>
<blockquote>
<div>Sergio Callegari, Federico Bizzarri <em>&#8220;Output Filter Aware
Optimization of the Noise Shaping Properties of ΔΣ Modulators via
Semi-Definite Programming&#8221;</em>, IEEE Transactions on Circuits and
Systems - Part I: Regular Papers. To appear in 2013.</div></blockquote>
<p>To this aim, some sample code is provided in the directory
<tt class="docutils literal"><span class="pre">Examples/TCAS1-2013</span></tt>.</p>
<p>The research paper provides 3 examples, in Sections V-a, V-b and V-c.</p>
<div class="section" id="example-in-section-v-a">
<h2>Example in section V-a<a class="headerlink" href="#example-in-section-v-a" title="Permalink to this headline">¶</a></h2>
<p>This example refers to the design of a Digital ΔΣ modulator that is
followed by a low pass filter in charge of removing the quantization
noise.</p>
<p>The corresponding code is provided in the file <tt class="docutils literal"><span class="pre">demo-lp.py</span></tt>. Once
PyDSM and all its pre-requisites are installed, this can be started
directly by opening a shell (command prompt) and typing:</p>
<div class="highlight-python"><pre>python demo-lp.py</pre>
</div>
<p>Alternatively, the script can be opened in Spyder and launched from
there.</p>
<p>The code runs, showing some intermediate output from the
optimizer. Then it provides the graphical output that is reported in
Figures 7 and 9 in the TCAS-I paper.</p>
<p>The code also provides a further graph, obtained by the time domain
simulation of the modulator. This includes 3 curves:</p>
<ol class="arabic simple">
<li>The output of a ΔΣ modulator passed through the filter, where the
modulator is designed by the technique in the TCAS-I paper.</li>
<li>The output of a ΔΣ modulator passed through the filter, where the
modulator is designed by the <tt class="docutils literal"><span class="pre">synthesizeNTF</span></tt> function from the
DELSIG toolbox.</li>
<li>The input of the modulator passed through the filter.</li>
</ol>
<p>This latter plot is meant to provide a graphical illustration that the
modulator obtained by the proposed design methodology is actually
working correctly. All the three plots should overlap almost
perfectly. However, zooming in, little differences should become
apparent, with the curve from the optimized modulator following the
curve given by the input signal slightly better.</p>
<p>The code also provides some numerical output, corresponding to the SNR
values reported in the research paper, obtained both with the
linearized model and with the actual time-domain simulation of the
modulator.</p>
<p>Note that the code does not provide any equivalent of Figure 8. For
this, it is necessary to introduce a loop so that the NTF is optimized
for different modulator orders. This is easy to achieve.</p>
<p>Neither the current code provides an equivalent of Figure 10. This
is anyway easy to achieve by using the <tt class="docutils literal"><span class="pre">plotPZ</span></tt> function in the
<tt class="docutils literal"><span class="pre">pydsm.delsig</span></tt> module.</p>
<p>As a final remark, the proposed example code is not particularly
elegant, but should be rather easy to read, also thanks to the many
comments.</p>
</div>
<div class="section" id="example-in-section-v-b">
<h2>Example in section V-b<a class="headerlink" href="#example-in-section-v-b" title="Permalink to this headline">¶</a></h2>
<p>This example refers to the design of a Digital ΔΣ modulator that is
followed by a bandpass filter in charge of removing the quantization
noise.</p>
<p>The corresponding code is provided in the file <tt class="docutils literal"><span class="pre">demo-bp.py</span></tt>. Once
PyDSM and all its pre-requisites are installed, this can be started
directly by opening a shell (command prompt) and typing:</p>
<div class="highlight-python"><pre>python demo-bp.py</pre>
</div>
<p>Alternatively, the script can be opened in Spyder and launched from
there.</p>
<p>The code runs, showing some intermediate output from the
optimizer. Then it provides the graphical output that is reported in
Figures 11 and 13 in the TCAS-I paper.</p>
<p>The code also provides a further graph, obtained by the time domain
simulation of the modulator. This includes 3 curves:</p>
<ol class="arabic simple">
<li>The output of a ΔΣ modulator passed through the filter, where the
modulator is designed by the technique in the TCAS-I paper.</li>
<li>The output of a ΔΣ modulator passed through the filter, where the
modulator is designed by the <tt class="docutils literal"><span class="pre">synthesizeNTF</span></tt> function from the
DELSIG toolbox.</li>
<li>The input of the modulator passed through the filter.</li>
</ol>
<p>This latter plot is meant to provide a graphical illustration that the
modulator obtained by the proposed design methodology is actually
working correctly. All the three plots should overlap almost
perfectly. However, zooming in, little differences should become
apparent, with the curve from the optimized modulator following the
curve given by the input signal slightly better.</p>
<p>The code also provides some numerical output, corresponding to the SNR
values reported in the research paper, obtained both with the
linearized model and with the actual time-domain simulation of the
modulator.</p>
<p>Note that the code does not provide any equivalent of Figure 12. For
this, it is necessary to introduce a loop so that the NTF is optimized
for different modulator orders. This is easy to achieve.</p>
<p>Nor the current code provides an equivalent of Figure 10. This
is anyway easy to achieve by using the <tt class="docutils literal"><span class="pre">plotPZ</span></tt> function in the
<tt class="docutils literal"><span class="pre">pydsm.delsig</span></tt> module.</p>
<p>As a final remark, the proposed example code is not particularly
elegant, but should be rather easy to read, also thanks to the many
comments.</p>
<p><strong>Warning</strong> The optimization of the modulator NTF can be particularly
time consuming in Windows, where only a 32 bit computation environment
is available and where some math libraries are not fully optimized to
the specific hardware platform in CVXOPT. For maximum performance, use
a modern 64 bit Linux distribution on a multi core CPU with fast
floating point math and instructions set with SIMD (SSEx) extensions
and possibly Advanced Vector Extensions (AVX).</p>
</div>
<div class="section" id="example-in-section-v-c">
<h2>Example in section V-c<a class="headerlink" href="#example-in-section-v-c" title="Permalink to this headline">¶</a></h2>
<p>This example refers to the design of a Digital ΔΣ modulator that is
followed by a two band filter in charge of removing the
quantization noise.</p>
<p>The corresponding code is provided in the file
<tt class="docutils literal"><span class="pre">demo-multiband.py</span></tt>. Once PyDSM and all its pre-requisites are
installed, this can be started directly by opening a shell (command
prompt) and typing:</p>
<div class="highlight-python"><pre>python demo-multiband.py</pre>
</div>
<p>Alternatively, the script can be opened in Spyder and launched from
there.</p>
<p>The code runs, showing some intermediate output from the
optimizer. Then it provides the graphical output that is reported in
Figures 15 and 17 in the TCAS-I paper.</p>
<p>Note that the sample code provides no comparison to Nagahara&#8217;s min-max
design strategy.</p>
<p>The code also provides a further graph, obtained by the time domain
simulation of the modulator. This includes 2 curves:</p>
<ol class="arabic simple">
<li>The output of a ΔΣ modulator passed through the filter, where the
modulator is designed by the technique in the TCAS-I paper.</li>
<li>The input of the modulator passed through the filter.</li>
</ol>
<p>This latter plot is meant to provide a graphical illustration that the
modulator obtained by the proposed design methodology is actually
working correctly. The two plots should overlap almost
perfectly.</p>
<p>The code also provides some numerical output, corresponding to the SNR
values reported in the research paper, obtained both with the
linearized model and with the actual time-domain simulation of the
modulator.</p>
<p>Note that the code does not provide any equivalent of Figure 16. For
this, it is necessary to introduce a loop so that the NTF is optimized
for different modulator orders. This is easy to achieve.</p>
<p>Nor the current code provides an equivalent of Figure 18. This
is anyway easy to achieve by using the <tt class="docutils literal"><span class="pre">plotPZ</span></tt> function in the
<tt class="docutils literal"><span class="pre">pydsm.delsig</span></tt> module.</p>
<p>As a final remark, the proposed example code is not particularly
elegant, but should be rather easy to read, also thanks to the many
comments.</p>
<p><strong>Warning</strong> The optimization of the modulator NTF can be particularly
time consuming in Windows, where only a 32 bit computation environment
is available and where some math libraries are not fully optimized to
the specific hardware platform in CVXOPT. For maximum performance, use
a modern 64 bit Linux distribution on a CPU with fast floating point
math and instructions set with SIMD (SSEx) extensions and possibly
Advanced Vector Extensions (AVX).</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">How to replicate the results in the TCAS-I paper</a><ul>
<li><a class="reference internal" href="#example-in-section-v-a">Example in section V-a</a></li>
<li><a class="reference internal" href="#example-in-section-v-b">Example in section V-b</a></li>
<li><a class="reference internal" href="#example-in-section-v-c">Example in section V-c</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="utility-modules.html"
                        title="previous chapter">Computation of the impulse response of a filter</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/replicate-tcas.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="utility-modules.html" title="Computation of the impulse response of a filter"
             >previous</a> |</li>
        <li><a href="index.html">PyDSM 0.5.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Sergio Callegari.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>